<!DOCTYPE HTML>

<head>
  <meta charset="UTF-8">
  <title>CSE 555: Project 2</title>
  <link rel="stylesheet" href="../cse555.css">
</head>
<body>
  <h1>CSE 555: Project 2</h1>
  <h2>Gradient-Domain Manipulations</h2>

  <h2>Robert Miller</h2>

  <div class="heading">
    <a href="http://www.cse.wustl.edu/~pless/classes/555/project2.html">Project Guidelines</a>
    ||
    <a href="http://www.cse.wustl.edu/~pless/classes/555/">Course Website</a>
    <br>
    <br>
  </div>

  <hr>

  <!-- PROJECT OVERVIEW -->
  <h3>Project Overview</h3>
  <p>
    When working with images, it is often easiest to represent them by their gradients rather than
    by specific pixel values: it is often more important to analyze and affect how pixels relate to
    one another than it is to use the intensity. As such, this project relates to several smaller
    components related to working with images in the domain of gradients.
    <br><br>
    The first of these sub-projects relates to rebuilding an image from its gradient and a single
    reference value. Because the image gradient effectively gives the difference between the value
    at a given pixel and the values of its neighbors, the values for all of a given pixels neighbors
    can be computed from its value and the value of the gradient at that point; when the method of
    reconstruction is applied across the entire image (in this context through the use of a system
    of equations), it is possible to accurately recover the entirety of the base image.
    <br><br>
    The second sub-project involved the implementation of Poisson blending to smoothly combine
    elements from multiple images into a single, seamless, and (hopefully) natural-looking combined
    image. To do so, the gradients from the two images are combined in such a way that they flow
    into one another cleanly; this will affect the color and intensity of the blended images, but
    the shapeand gradient of the image will be maintained (and, as stated above, the image gradient
    is usually more important than color or intensity).
    <br><br>
    The third component modifies the implementation of Poisson blending to preserve the gradient
    with the larger magnitude, potentially resulting in more naturalistic combinations of images
    which preserve more of the texture of the two images (rather than cutting a whole in one and
    plugging in the other).
    <br><br>
    In addition to these components, some other, smaller applications of gradient-domain processing
    were implemented as extra credit (described in the Extra Credit section below).
  </p>

  <hr>

  <!-- GRADIENT RECONSTRUCTION -->
  <h3>Reconstruction from Gradients</h3>
  <p>
    Logically speaking, the task of reconstructing an image means finding a set of pixel values
    which will have the same gradient as the source image and which has the same value at a given
    reference point. These constraints can be represented cleanly as a system of equations; MATLAB
    provides some excellent utilities for working with systems of equations using sparse matrices.
    This means that the entire process of reconstruction amounts to creating these constraints,
    solving for the values which satisfy them, and then convrting the obtained solution vector back
    into an image.
    <br><br>
    The system of equations (when represented in the form of matrices) appears as <i>Av = b</i>,
    where <i>A</i> and <i>b</i> are the provided constraints and <i>v</i> are the variables to be
    solved for. In MATLAB, these matrices are prepared as follows:
    <br><br>
    <div class="codeWrapper">
<code>[height, width] = size(image); 
pixelIndices = zeros(height, width); 
pixelIndices(1:height*width) = 1:height*width;

A = sparse(height * width * 2 - height - width + 1, height * width);
b = sparse(height * width * 2 - height - width + 1, 1);</code>
    </div>
    <br>
    These matrices are declared to be sparse as a means of saving on both memory and processing
    usage; MATLAB considers all of the unspecified values in a sparse matrix to be 0, meaning that
    operations on the matrix can be completed much more efficiently by simply skipping over the
    majority of values (considering only the ones which have been explicitly specified). The two
    matrices are sized to hold the precise number of constraints that that will be provided, given
    in the code below:
    <br><br>
    <div class="codeWrapper">
<code><span class="reserved">for</span>  x = 1:width-1
  <span class="reserved">for</span>  y = 1:height
    e = e + 1;
    A(e, pixelIndices(y,x+1)) = 1;
    A(e, pixelIndices(y,x)) = -1;
    b(e) = image(y,x+1) - image(y,x);
  <span class="reserved">end</span> 
<span class="reserved">end</span> 

<span class="reserved">for</span> x = 1:width
  <span class="reserved">for</span>  y = 1:height-1
    e = e + 1;
    A(e, pixelIndices(y+1,x)) = 1;
    A(e, pixelIndices(y,x)) = -1;
    b(e) = image(y+1,x) - image(y,x);
  <span class="reserved">end</span> 
<span class="reserved">end</span> 

e = e + 1
A(e, pixelIndices(1,1)) = 1;
b(e) = image(1,1);</code>
    </div>
    <br>
    The first and second segments of this code govern the gradient in the horizontal and vertical
    directions respectively; the third piece specifies that the value of the top left pixel nees to
    be the same in both the source and target images (thus setting the reference point for the
    reconstruction). The value of <code>e</code> starts at 0 and is used to uniquely identify
    contstraints.
    <br><br>
    Once these constraints have been fully specified, the last piece is to solve for the correct
    values and reshape the solution vector into the expected image dimensions:
    <br><br>
    <div class="codeWrapper">
<code>reconstructed = full(reshape(A \ b, [width, height]));</code>
    </div>
    <br>
    In one line, this code first solves the system of equations, then reshapes the vector into a
    matrix with the same dimensions as the source image, and finally converts from a sparse matrix
    into a fully-defined matrix (which MATLAB requires for image data).
    <br><br>
    <b>TODO&mdash;PUT EXAMPLES AND RESULTS HERE</b>
  </p>

  <hr>

  <!-- POISSON BLENDING -->
  <h3>Poisson Blending</h3>
  <p>
    
  </p>

  <hr>

  <!-- MIXED-GRADIENT BLENDING -->
  <h3>Blending with Mixed Gradients</h3>
  <p>
    
  </p>

  <hr>

  <!-- CHALLENGES FACED -->
  <h3>Design Challenges</h3>
  <p>

  </p>

  <hr>

  <!-- IMPLEMENTATION ADVANTAGES -->
  <h3>Design Advantages</h3>
  <p>

  </p>

  <hr>

  <!-- EXTRA CREDIT -->
  <h3>Extra Credit</h3>
  <p>
    
  </p>

  
</body>
