<!DOCTYPE HTML>

<head>
  <meta charset="UTF-8">
  <title>CSE 555: Project 4</title>
  <link rel="stylesheet" href="../cse555.css">
  <script type="text/javascript" src="http://latex.codecogs.com/latexit.js"></script>
</head>
<body>
  <h1>CSE 555: Project 4</h1>
  <h2>Video Textures</h2>

  <h2>Robert Miller</h2>

  <div class="heading">
    <a href="http://www.cse.wustl.edu/~pless/classes/555/project4.html">Project Guidelines</a>
    ||
    <a href="http://www.cse.wustl.edu/~pless/classes/555/">Course Website</a>
    <br>
    <br>
    <img src="images/water_generated.gif" alt="CSE 555: Project 4" />
    <br>
  </div>

  <hr>

  <!-- PROJECT OVERVIEW -->
  <h3>Project Overview</h3>
  <p>
    Video can make for a more attractive medium than still photography (if nothing else, the motion
    from one frame to another is likely to catch the eye), but it is fundamentally limited by the
    simple fact that video clips are finite: all videos will come to an end, at which point the
    attractive motion will either abruptly stop or will abruptly cut back to the beginning. Although
    there are techniques for masking this looping by matching up the final frame with the first one,
    the artificiality of the resultant loop is often evident in the inherent repetition in the
    video.
    <br><br>
    Ideally, instead of looping, videos would simply continue on indefinitely&mdash;precisely where
    video textures come in. Video textures, defined and described in
    <a href="http://www.cc.gatech.edu/cpl/projects/videotexture/SIGGRAPH2000/index.htm">this
    paper</a>, are a way of using existing frames in a video to extend placyback for an arbitrarily
    long time. To do so, a set of probabilities for transitions from one frame to another are
    calculated; this table of probabilities is referenced to generate novel videos (for this
    implementation, videos are generated based on a desired frame count provided by the user, but
    this could in principle be used to select the next frame in real time, allowing an endless
    video to be generated without obvious looping points).
    <br><br>
    All code written for this project can be found in my repository
    <a href="https://github.com/bionicOnion/CSE555/tree/master/VideoTextures">here</a>.
  </p>

  <hr>

  <!-- TEXTURE CREATION -->
  <h3>Video Texture Creation</h3>
  <p>
    As a first step, the provided texture video is loaded from its file and cut into its component
    frames (which are then stored in a <code>VideoFrames</code> object, which is itself a wrapper
    for an <code>std::vector&lt;cv::Mat&gt;</code>). The following listing shows this process; for
    brevity, some non-relevant code (for storing metadata about the video) has been omitted:
    <br><br>
    <div class="codeWrapper">
<code>cv::VideoCapture textureVideo(videoFile);

<span class="reserved">auto</span> framesRead = -1;
<span class="reserved">auto</span> frameCount = MIN(<span class="reserved">static_cast</span>&lt;<span class="reserved">unsigned int</span>&gt;(textureVideo.get(CV_CAP_PROP_FRAME_COUNT)), numFrames);
frames.resize(frameCount);
cv::Mat frame;
<span class="reserved">while</span> (textureVideo.read(frame) &ampl;&amp; ++framesRead &lt; frameCount)
  cv::resize(frame, frames[framesRead], cv::Size(), VID_SCALE_FACTOR, VID_SCALE_FACTOR);</code>
    </div>
    <br>
    Given this collection of frames, the set of probabilities of transitioning from one frame to
    another is computed. First, the sum of squared difference between pixel intensities is computed
    between every pair of frames in the video:
    <br><br>
    <div class="codeWrapper">
<code><span class="reserved">for</span> (<span class="reserved">unsigned</span> i = 0; i &lt; frameCount; ++i)
{
  <span class="reserved">for</span> (<span class="reserved">auto</span> j = i; j &lt; frameCount; ++j)
  {
    costMatrix.at&lt;<span class="reserved">double</span>&gt;(i, j) = 0;
    <span class="reserved">for</span> (<span class="reserved">auto</span> ii = 0; ii &lt; video.getFrame(i).rows; ++ii)
    {
      <span class="reserved">for</span> (<span class="reserved">auto</span> jj = 0; jj &lt; video.getFrame(i).cols; ++jj)
      {
        <span class="reserved">int16_t</span> error = video.getFrame(i).at&lt;<span class="reserved">uint8_t</span>&gt;(ii, jj) - video.getFrame(j).at&lt;<span class="reserved">uint8_t</span>&gt;(ii, jj);
        costMatrix.at&lt;<span class="reserved">double</span>&gt;(i, j) += error * error / frameCount;
      }
    }
  }
}</code>
    </div>
    <br>
    Next, a binomial weighting is applied to attempt to maintain continuity between frames (the
    error between the prior and following frames is included into an updated error value):
    <br><br>
    <div class="codeWrapper">
<code><span class="reserved">auto</span> costMatrixMod = cv::Mat(frameCount, frameCount, CV_64F);
<span class="reserved">for</span> (unsigned i = 0; i &lt; frameCount; ++i)
{
  <span class="reserved">for</span> (<span class="reserved">auto</span> j = i; j &lt; frameCount; ++j)
  {
    costMatrixMod.at&lt;<span class="reserved">double</span>&gt;(i, j) = 0;
    <span class="reserved">for</span> (int k = 0, ii = i - WEIGHT_TAP_COUNT, jj = j - WEIGHT_TAP_COUNT;
         k &lt; (WEIGHT_TAP_COUNT * 2) + 1;
         ++k, ++ii, ++jj)
    {
      <span class="reserved">if</span> (ii &lt; 0 || ii &gt;l= frameCount || jj &lt; 0 || jj &gtl= frameCount)
        costMatrixMod.at&lt;<span class="reserved">double</span>&gt;l(i, j) += WEIGHTS[k];
      <span class="reserved">else</span>
        costMatrixMod.at&lt;<span class="reserved">double</span>&gt;l(i, j) += WEIGHTS[k] * costMatrix.at&lt;<span class="reserved">double</span>&gtl(ii, jj);
    }
    costMatrixMod.at&lt;<span class="reserved">double</span>&gt;l(j, i) = costMatrixMod.at&lt;<span class="reserved">double</span>&gt;l(i, j);
  }
}</code>
    </div>
    <br>
    Finally, the probabilities themselves are computed by computing the average value of all
    non-zero entries, computing an exponential function based on the error values and a parameter
    &sigma; (set to 0.025 in the examples on this page), and then normalizing the results such that
    the results in every column&mdash;corresponding to the values for a given image&mdash;sum to
    one, forming proper probabilities:
    <br><br>
    <div class="codeWrapper">
<code><span class="reserved">auto</span> avg = 0.0;
<span class="reserved">auto</span> avgVals = 0;
<span class="reserved">for</span> (<span class="reserved">unsigned</span> i = 0; i &lt; frameCount; ++i)
{
  <span class="reserved">for</span> (<span class="reserved">auto</span> j = 0; j &lt; frameCount; ++j)
  {
    costMatrix.at&lt;<span class="reserved">double</span>&gt;(i, j) = costMatrixMod.at&lt;<span class="reserved">double</span>&gt;(i, j);
    <span class="reserved">if</span> (costMatrix.at&lt;<span class="reserved">double</span>&gt;(i, j) != 0)
    {
      avg += costMatrix.at&lt;<span class="reserved">double</span>&gt;(i, j);
      ++avgVals;
    }
  }
}
avg /= avgVals;

<span class="reserved">for</span> (<span class="reserved">unsigned</span> i = 0; i &lt; frameCount - 1; ++i)
{
  <span class="reserved">for</span> (<span class="reserved">auto</span> j = 0; j &lt; frameCount; ++j)
  {
    costMatrix.at&lt;<span class="reserved">double</span>&gt;(i, j) = exp(-costMatrix.at&lt;<span class="reserved">double</span>&gt;(i + 1, j) / (avg * sigmaFactor));
  }
}
<span class="reserved">for</span> (<span class="reserved">auto</span> j = 0; j &lt; frameCount; ++j)
  costMatrix.at&lt;<span class="reserved">double</span>&gt;(frameCount - 1, j) = 0;

<span class="reserved">for</span> (<span class="reserved">unsigned</span> i = 0; i &lt; frameCount; ++i)
{
  <span class="reserved">auto</span> sum = 0.0;
  <span class="reserved">for</span> (<span class="reserved">auto</span> j = 0; j &lt; frameCount; ++j)
  {
    sum += costMatrix.at&lt;<span class="reserved">double</span>&gt;(i, j);
  }
  <span class="reserved">for</span> (<span class="reserved">auto</span> j = 0; j &lt; frameCount; ++j)
  {
    costMatrix.at&lt;<span class="reserved">double</span>&gt;(i, j) /= sum;
  }
}</code>
    </div>
    <br>
    The following examples show images of the probability matrices computed in the fashion
    defined above:

    <hr class="invisible" />

    <figure>
      <a href="images/bird_probs.bmp">
        <img src="images/bird_probs.bmp" alt="Probabilities for the bird video" />
      </a>
      <figcaption>The computed probabilites for the bird video texture</figcaption>
    </figure>

    <figure>
      <a href="images/waterfall_probs.bmp">
        <img src="images/waterfall_probs.bmp" alt="Probabilities for the waterfall video" />
      </a>
      <figcaption>The computed probabilites for the waterfall video texture</figcaption>
    </figure>

    <hr class="invisible" />

    Given these probabilities, the last step in the process is to generate some new video from
    the existing frames with probabalistic frame transitions. Starting from the first frame of
    the original video, the frame at the given index is inserted into the video and then the
    index of the next frame is selected by sampling from the computed distribution:
    <br><br>
    <div class="codeWrapper">
<code><span class="reserved">auto</span> currFrameIdx = 0;
<span class="reserved">for</span> (<span class="reserved">auto</span> i = 0; i &lt; desiredLength; ++i)
{
  genVid &lt;&lt; texVideo.getFrame(currFrameIdx);
  currFrameIdx = sampleFromDistribution(transitionProbs, currFrameIdx);
}</code>
    </div>
    <br>
    The <code>sampleFromDistribution</code> function is implemented as follows:
    <br><br>
    <div class="codeWrapper">
<code><span class="reserved">auto</span> randVal = <span class="reserved">static_cast</span>&lt;<span class="reserved">float</span>gt;(rand()) / <span class="reserved">static_cast</span>;<span class="reserved">auto</span>gt;(RAND_MAX);
<span class="reserved">auto</span> selectedIndex = 0;
<span class="reserved">auto</span> distSum = distribution.at&lt;<span class="reserved">double</span>gt;(currIndex, selectedIndex);
<span class="reserved">while</span> (distSum &lt; randVal &amp;&amp; selectedIndex &lt; distribution.rows - 1)
{
  ++selectedIndex;
  distSum += distribution.at&lt;<span class="reserved">double</span>gt;(currIndex, selectedIndex);
}
<span class="reserved">return</span> selectedIndex;</code>
    </div>
    <br>
  </p>

  <hr>

  <!-- EXAMPLES -->
  <h3>Examples</h3>
  <p>
    For both of the following examples, the animation on the left is the source video that was used
    to generate the video texture; the right animation is the generated video.

    <hr class="invisible" />

    <figure>
      <a href="images/bird_cut.gif">
        <img src="images/bird_cut.gif" alt="Bird video texture" />
      </a>
      <figcaption>Video texture of a bird</figcaption>
    </figure>

    <figure>
      <a href="images/bird_generated.gif">
        <img src="images/bird_generated.gif" alt="Bird generated video" />
      </a>
      <figcaption>Generated video of a bird</figcaption>
    </figure>

    <figure>
      <a href="images/waterfall_cut.gif">
        <img src="images/waterfall_cut.gif" alt="Waterfall video texture" />
      </a>
      <figcaption>Video texture of a waterfall</figcaption>
    </figure>

    <figure>
      <a href="images/waterfall_generated.gif">
        <img src="images/water_generated.gif" alt="Waterfall generated video" />
      </a>
      <figcaption>Generated video of a waterfall</figcaption>
    </figure>
  </p>

  <hr>

  <!-- ANALYSIS -->
  <h3>Analysis</h3>
  <p>
  The results obtained were reasonably good (although some tweaking of parameters might have been
  able to produce better results; the setting for &sigma; was largely arbitrary and came about as
  the result of limited trial and error&mdash;changing the value amounts to a tradeoff between
  selecting possible looping points and allowing chunks of continuous video to play unimpeded).
  <br><br>
  As it stands, some visible jumps are still present in the generated videos; addressing this issue
  would likely mean both tweaking parameters and implementing some of the additional processing
  suggested in the paper (such as finding locally maximal points to be the only possible
  transitions, thus reducing the probability of a given transition being jumpy, or using image
  warping/fading to mask the transition as it occurs).
  <br><br>
  The main issue, however, is the simple fact that processing video takes time, and the
  implementation described above is still sometwhat poorly optimized (namely because it computes
  an embarassingly parallel problem in a single thread). It is for this reason that the resulting
  videos are lower in resolution than the source videos; making the processing feasible meant
  that reducing the amount of data to process was necessary. I had considered attempting to leverage
  the GPU to compute the probabilities, but ultimately elected to stay with the "na&iuml;ve"
  version above.
  </p>

</body>